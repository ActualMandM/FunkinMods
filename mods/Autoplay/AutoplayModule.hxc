import funkin.Conductor;
import funkin.input.PreciseInputManager;
import funkin.modding.events.ScriptEvent;
import funkin.modding.module.Module;
import funkin.play.PlayState;
import funkin.play.scoring.Scoring;
import funkin.play.stage.Stage;
import funkin.save.Save;
import funkin.ui.options.OptionsState;
import funkin.util.Constants;

/**
 * A module that automatically presses notes
 * in PlayState with perfect timing.
 *
 * @author RagdollClash
 */
class AutoplayModule extends Module
{
  var enabled:Bool = true;

  var options:Dynamic = {
    enabled: true
  };

  function new()
  {
    super("AutoplayModule");

    if (Save.instance.modOptions.get("mandm.autoplay") == null)
    {
      Save.instance.modOptions.set("mandm.autoplay", options);
      Save.instance.flush();
    }
    else
    {
      options = Save.instance.modOptions.get("mandm.autoplay");
    }

    if (options.enabled == null)
    {
      options.enabled = true;
    }

    enabled = options.enabled;
  }

  override function onStateChangeEnd(event:StateChangeScriptEvent):Void
  {
    if (Std.isOfType(event.targetState, OptionsState))
    {
      var prefs = event.targetState.optionsCodex.pages.get("preferences");

      prefs.createPrefItemCheckbox("Autoplay", "If enabled, songs will be played automatically.\nScores will not be saved with autoplay enabled.", function(value)
      {
        options.enabled = value;
        enabled = value;
      }, options.enabled);
    }
    else
    {
      Save.instance.modOptions.set("mandm.autoplay", options);
      Save.instance.flush();
    }

    super.onStateChangeEnd(event);
  }

  var playerNotes:Array<SongNoteData> = [];
  var holdData:Array<Float> = [0, 0, 0, 0];

  override function onSongLoaded(event:SongLoadScriptEvent)
  {
    super.onSongLoaded(event);

    if (enabled)
    {
      var state:PlayState = PlayState.instance;

      if (state != null && !state.isBotPlayMode)
      {
        state.isPracticeMode = true;

        playerNotes = [];
        holdData = [0, 0, 0, 0];

        for (note in event.notes)
        {
          if (note.getMustHitNote() && note.time >= state.startTimestamp)
          {
            var apNote:SongNoteData = note.clone();
            if (apNote.length == 0) apNote.length += (3 / 24) * 1000;
            playerNotes.push(apNote);
          }
        }
      }
    }
  }

  override function onUpdate(event:ScriptEvent):Void
  {
    super.onUpdate(event);

    if (enabled)
    {
      var state:PlayState = PlayState.instance;

      if (playerNotes.length > 0 && state != null && !state.isGamePaused && !state.isBotPlayMode)
      {
        var pressQueue:Array<PreciseInputEvent> = state.inputPressQueue;
        var releaseQueue:Array<PreciseInputEvent> = state.inputReleaseQueue;

        for (note in playerNotes)
        {
          if (Conductor.instance.songPosition >= note.time)
          {
            if (holdData[note.data] == 0)
            {
              pressQueue.push({noteDirection: note.data, timestamp: PreciseInputManager.getCurrentTimestamp()});
            }

            if (holdData[note.data] >= note.length)
            {
              holdData[note.data] = 0;
              playerNotes.remove(note);
              releaseQueue.push({noteDirection: note.data, timestamp: PreciseInputManager.getCurrentTimestamp()});
            }
            else
            {
              holdData[note.data] += (event.elapsed * Constants.MS_PER_SEC);

              var stage:Stage = state.currentStage;

              if (stage != null && stage.getBoyfriend() != null && stage.getBoyfriend().isSinging())
              {
                stage.getBoyfriend().holdTimer = 0;
              }
            }
          }
        }
      }
    }
  }
}
